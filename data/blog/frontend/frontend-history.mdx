---
title: 프론트엔드 히스토리
date: '2025-09-03'
tags: ['frontend']
draft: false
summary: 프론트엔드의 역사와 발전 과정에 대해 정리
---

웹의 시작부터 현재에 이르기까지 프론트엔드 기술은 끊임없이 발전해왔다. 초기에는 단순한 HTML과 CSS로 구성된 정적인 페이지가 주를 이루었지만, 시간이 지나면서 JavaScript의 등장과 함께 동적인 웹 애플리케이션이 가능해졌다. 이번 글에서는 프론트엔드의 역사와 발전 과정을 정리해보자.

## TL;DR

- 1990년대는 MPA(Multi-Page Application) 시대로, 서버에서 HTML을 렌더링해 응답하는 방식이 주류였다.
- 2000년대 중반, AJAX 기술의 발전으로 동적 웹 애플리케이션 구현이 가능해졌다.
- 2010년대에는 SPA(Single Page Application) 기반의 다양한 프레임워크/라이브러리가 주류를 이루게 되었다.
- 2010년대 후반부터는 SSR(Server Side Rendering)과 SSG(Static Site Generation) 방식이 다시 주목받기 시작했다.
- 현재에 이르러서는 유저 경험을 더욱 최적화하기 위해 ISR(Incremental Static Regeneration), RSC(React Server Components), PPR(Partial Prerendering) 등의 기술이 등장하고 있다.

## 1990년대: 웹의 탄생과 MPA 시대

웹의 초기 애플리케이션은 **MPA(Multi-Page Application)** 구조였다.
아래 그림처럼 브라우저에서 웹 서버에 페이지 요청을 하면, 서버는 요청 경로에 있는 HTML 파일을 응답하여 브라우저에서 보여주는 간단한 구조였다.

<Image
  alt="web-server"
  width={600}
  height={500}
  src="/static/images/web-server.webp"
  className="mx-auto"
/>

아래 사진은 초기 네이버 홈페이지의 모습인데, 주로 `<a>` 태그를 통해 페이지 간 이동이 이루어졌다.
사용자가 페이지를 요청할 때마다 서버가 HTML을 렌더링해 응답했고, 매 페이지 요청 시마다 페이지는 전체 새로고침되었다.

<Image
  alt="early-naver"
  width={500}
  height={400}
  src="/static/images/early-naver.webp"
  className="mx-auto"
/>

이 시절에는 지금처럼 프론트엔드 개발자라는 직군이 따로 존재하지 않았다.
서버 개발자가 HTML을 함께 작성하거나, 디자이너가 CSS를 얹는 정도였다.
JavaScript도 존재했지만 활용 범위는 단순한 이벤트 처리(버튼 클릭, 입력 검증) 수준에 머물렀다.
즉, **웹 개발자**라는 큰 범주 안에서 모든 게 처리되었다.

그러다가 날씨, 뉴스 등의 최신 정보를 제공하는 웹 서비스가 등장하기 시작했다.
실시간으로 최신 정보를 제공하기 위해 JSP, ASP, PHP 같은 언어들에서는 유저가 페이지를 요청했을 때 서버에서 HTML을 동적으로 생성하는 **Server Side Template**이 보편화되었다.

```php
<!-- php 예제 코드 -->
<html>
  <body>
    <h1>뉴스 목록</h1>
    <ul>
      <?php foreach ($articles as $article): ?>
        <li><?= $article['title'] ?> - <?= $article['date'] ?></li>
      <?php endforeach; ?>
    </ul>
  </body>
</html>
```

이러한 **Server Side Template**의 단점은 매 요청 시마다 DB를 조회해서 필요한 값을 내려주기 위해 계산하고, HTML을 새로 렌더링하는 등 서버 비용이 크게 든다는 점이었다.
심지어 같은 레이아웃(헤더, 푸터 등)을 가진 페이지라도 매번 새로 렌더링해야 해서 비효율적이었다.

따라서 동시접속자 수가 많아질 수록 CPU, 메모리 사용량이 크게 늘어났고, 서버 비용이 급증하게 되었다.
또한 여전히 유저들은 매 페이지를 요청할 때마다 여전히 전체 페이지가 새로고침되는 경험을 해야 했다.

## 2000년대: AJAX와 동적 웹의 등장

2000년대 중반, **[AJAX(Asynchronous JavaScript and XML)](<https://en.wikipedia.org/wiki/Ajax_(programming)>)** 기술이 주목받으면서 상황이 달라졌다.

전체 페이지를 새로고침하지 않고도, 필요한 데이터만 서버에서 받아와 부분적으로 화면을 갱신할 수 있게 되었다.
Gmail, Google Maps 같은 서비스가 이 흐름을 선도하면서 "데스크톱 애플리케이션 같은 웹앱"에 대한 수요가 커졌다.
이것이 **SPA(Single Page Application)** 시대를 여는 신호탄이었다.

### 1. AJAX의 탄생 (2005)

2005년, Jesse James Garrett이 <b>AJAX(Asynchronous JavaScript and XML)</b>라는 용어를 정의하면서 본격적으로 주목받기 시작했다.

AJAX란 [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)를 활용해 비동기 요청을 보내고, 서버에서 받은 데이터를 JavaScript로 처리해서 화면 일부만 갱신하는 기법이다.

```html
<!-- AJAX 예제 코드 -->
<!DOCTYPE html>
<html>
  <head>
    <title>AJAX Example</title>
    <script type="text/javascript">
      function loadData() {
        // 1. XMLHttpRequest 객체 생성
        var xhr = new XMLHttpRequest();

        // 2. 서버 응답이 준비되었을 때 실행될 콜백 정의
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
            // 서버에서 받은 데이터를 화면 일부에 출력
            document.getElementById('result').innerHTML = xhr.responseText;
          }
        };

        // 3. 비동기 요청 초기화
        xhr.open('GET', 'data.txt', true);

        // 4. 요청 전송
        xhr.send();
      }
    </script>
  </head>
  <body>
    <h1>초기 AJAX 예제</h1>
    <button onclick="loadData()">데이터 불러오기</button>
    <div id="result"></div>
  </body>
</html>
```

AJAX가 널리 알려지기 시작하면서 유저들에게 전체 새로고침 없는 부드러운 사용자 경험(UX)을 줄 수 있게 되었고, 서버는 전체 페이지를 다시 렌더링할 필요 없이 필요한 데이터만 주면 되므로 서버 비용을 절감할 수 있게 되었다.

### 2. jQuery의 등장 (2006)

2006년, jQuery가 등장하면서 AJAX 사용이 더욱 간편해졌다.
당시에는 브라우저별로 DOM API, 이벤트 처리 방식, XMLHttpRequest 지원이 제각각이었다. 따라서 개발자가 직접 호환성 처리를 하려면 코드가 복잡해지고 유지보수가 힘들었다.
jQuery가 통일된 문법으로 DOM 조작과 AJAX 요청을 쉽게 할 수 있도록 해주어, 개발자들은 복잡한 JavaScript 코드를 작성하지 않고도 손쉽게 비동기 요청을 처리할 수 있게 되었다.

```js
// 순수 js로 DOM 선택
document.getElementById('result');

// jQuery로 DOM 선택
$('#result');

// 순수 XMLHttpRequest
var xhr = new XMLHttpRequest();
xhr.open('GET', '/data', true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();

// jQuery AJAX
$.ajax({
  url: '/data',
  method: 'GET',
  success: function (response) {
    console.log(response);
  },
});
```

이런 간편함 덕분에 2010년대 초반까지 사실상 프론트엔드의 표준 라이브러리가 되었다.

그러나 jQuery도 다음과 같은 한계가 있었다.

#### 1. 상태 관리(State Management)의 어려움

- jQuery는 DOM 조작 중심 → “화면에 있는 요소를 직접 바꾸는 방식”.
- 작은 프로젝트에서는 문제가 없지만, 페이지가 커지고 UI가 복잡해지면 어떤 상태가 어디에 있는지 추적하기 어려움.
- 예: 탭 전환, 모달, 폼 값, 서버 데이터가 얽히면 이벤트 콜백이 많아지고 코드가 얽히는 콜백 지옥(callback hell) 발생.

#### 2. 컴포넌트화(Componentization)의 부재

- jQuery는 단일 함수 단위로 코드 재사용이 가능하지만, UI 자체를 독립적인 컴포넌트 단위로 만들 수 없음.
- 예를 들어, 같은 버튼 UI가 여러 곳에 있는데 동작을 바꾸고 싶으면 각각 직접 수정해야 함 → 유지보수 어려움.

#### 3. 페이지 전체 흐름 제어 어려움

- 브라우저 URL과 화면 상태를 통합 관리하는 기능이 없음.
- 개발자가 직접 다음을 구현해야 함:
  - URL 변경 감지 (window.onpopstate 등)
  - 화면 요소 교체/숨김 처리
  - 상태 관리 (어떤 탭, 모달, 리스트가 열려 있는지)
- 프로젝트가 커질수록 화면 전환 로직이 DOM 조작 코드가 여기저기에 흩어져, 유지보수와 버그 추적이 어려움.

#### 4. 테스트와 구조화 어려움

- jQuery 코드 대부분이 직접 DOM 조작 + 이벤트 바인딩 → 단위 테스트, 코드 재사용, 모듈화 어려움.
- 프로젝트가 커질수록 버그 발생, 코드 가독성 저하 문제가 심화됨.

이에 따라 다른 대안의 필요성이 대두되었다.

## 2010년대: SPA 프레임워크의 등장

위에서 설명했던 것처럼 웹 앱 규모가 커지고 복잡해지면서 상태 관리, 구조화 문제가 발생했다.

이 때 등장했던 대표 프레임워크/라이브러리는 다음과 같다.

- [Backbone.js](https://backbonejs.org/) (2010): 초창기 MVC 패턴 시도.
- [AngularJS](https://angularjs.org/) (2010): 양방향 데이터 바인딩 제공.
- [React](https://react.dev/) (2013): Virtual DOM, 컴포넌트 기반 혁신.
- [Vue.js](https://vuejs.org/) (2014): 가볍고 배우기 쉬운 대안.

이 글에서는 이러한 SPA 프레임워크/라이브러리들이 왜 등장했고 어떤 문제를 해결했는지, 원리는 무엇인지 등에 초점을 맞춰서 작성하겠다.

(각 프레임워크/라이브러리별 상세한 특징은 [여기](https://velog.io/@minsangk/%EC%A7%A7%EA%B2%8C-%EC%8D%A8%EB%B3%B4%EB%8A%94-%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%97%AD%EC%82%AC#3-phpaspjs)에 정리되어 있으니 참고)

### 1. SPA란?

SPA(Single Page Application)는 단일 HTML 페이지로 구성된 웹 애플리케이션을 의미한다. 사용자가 웹 애플리케이션을 사용할 때, 페이지 전체를 새로고침하지 않고 필요한 부분만 동적으로 업데이트하여 부드러운 사용자 경험을 제공한다.

React를 예시로 들면, 아래와 같이 `index.html` 파일 하나로 시작한다.

```html:index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>React Example</title>
  </head>
  <body>
    <!-- React가 마운트될 지점 -->
    <div id="root"></div>
    <!-- 번들된 React 코드 -->
    <script src="bundle.js"></script>
  </body>
</html>
```

처음에는 빈 화면만 렌더링되었다가, React 스크립트가 로드되고 실행되면서 `#root` 요소에 React 컴포넌트가 마운트되어 화면이 동적으로 구성된다.

이러한 구조를 **CSR(Client Side Rendering)** 이라고 한다.

<Image
  src="/static/images/csr.webp"
  alt="csr"
  width={600}
  height={400}
  className="mx-auto"
/>

왜 이런 구조를 사용할까?

- **사용자에게 더 좋은 UX를 제공할 수 있다**: SPA는 화면 전환 시 클라이언트 사이드 라우팅을 제공하므로, 페이지 이동 시마다 페이지 새로고침 효과를 없앨 수 있다.
- **서버 부하를 줄일 수 있다**: MPA 시절에는 모든 HTML 파일 렌더링과 실시간 계산 처리를 서버에서 담당했었다. 하지만 SPA는 초기 로드 시 필요한 HTML, CSS, JS 파일을 받아오고, 이후에는 필요한 데이터만 서버에서 받아와 클라이언트에서 렌더링하므로 서버 부하가 줄어든다.

그런데 이런 구조에서 어떻게 URL 주소를 변경하고, 페이지 간 전환을 부드럽게 처리할 수 있는걸까?

### 2. SPA에서의 라우팅

React를 사용할 때 보통 [React Router](https://reactrouter.com/)를 사용하는데, React Router는 페이지 간 전환을 쉽게 해주는 라이브러리이다. 이를 통해 URL을 변경하고, 사용자가 다른 페이지로 이동할 때 전체 페이지를 새로고침하지 않고도 필요한 컴포넌트만 업데이트할 수 있다.

React Router 같은 라이브러리 내부에서는 [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)를 사용하여 브라우저의 주소 표시줄을 변경한다. 예를 들어, [history.pushState()](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) 메서드를 사용하면 페이지를 새로고침하지 않고도 URL을 변경할 수 있다.

```js
// URL 변경 예시
history.pushState({ page: 1 }, '', '/page1');
```

더 자세한 내용은 [이 글](https://promleeblog.com/blog/post/248-6-react-router#react-router는-어떻게-동작할까요)에서 참조하길 바란다.

### 3. 좀 더 수월해진 상태 관리

MPA와 jQuery 시절에는 상태 관리를 위해 주로 전역 변수를 사용하는 방식이 일반적이었다. 이로 인해 상태 변화에 대한 추적이 어려워지고, 버그 발생 가능성이 높아졌다.

대 SPA 시대에 이르러서 상태 관리를 위해 다양한 라이브러리와 패턴들이 등장했다. 예를 들어, Flux 패턴 기반의 Redux, Observable 패턴 기반의 MobX, Atom 패턴 기반의 Recoil 등 상태 관리 라이브러리를 사용하여 애플리케이션의 상태를 중앙에서 관리하고, 컴포넌트 간의 데이터 흐름을 명확하게 할 수 있었다. 이를 통해 상태 변화에 대한 예측 가능성을 높이고, 디버깅을 용이하게 할 수 있었다.

### 4. SPA의 단점은?

그러나 이런 SPA도 치명적인 단점들이 존재했다.

- **초기 로딩 속도**: SPA는 초기 로드 시 모든 리소스를 한 번에 불러오기 때문에, 첫 페이지 로딩 속도가 느릴 수 있다. 특히, 대규모 애플리케이션에서는 초기 번들이 커져서 로딩 시간이 길어질 수 있다.
- **SEO 문제**: SPA는 클라이언트 사이드에서 빈 페이지를 렌더링한 이후 JS가 모두 로드된 뒤에 페이지 내용들이 채워지기 때문에, 검색 엔진이 페이지 내용을 제대로 인식하지 못할 수 있다.

## 2010년대 후반: SSR과 SSG의 부활

SPA의 단점들이 부각되면서, **SSR(Server Side Rendering)** 과 **SSG(Static Site Generation)** 방식이 다시 주목받기 시작했다. 이 두 가지 방식은 각각의 장점을 살려 SPA의 단점을 보완할 수 있는 방법으로 떠올랐다.

### 1. SSR (Server Side Rendering)

서버에서 HTML을 미리 렌더링하여 클라이언트에 전달하는 방식. 실시간 데이터 반영과 SEO 문제를 해결할 수 있다. 앞에서 설명했던 Server Side Template 방식과 유사하지만, 클라이언트에서 hydration이 이루어진다는 점에서 차이가 있다.

<Image
  src="/static/images/ssr.webp"
  alt="ssr"
  width={600}
  height={500}
  className="mx-auto"
/>

- **원리**: 브라우저가 페이지 요청 → 서버에서 초기 HTML 생성 → 클라이언트에서 React/Vue가 hydration하여 SPA처럼 동작
- **대표적인 프레임워크**
  - [Next.js](https://nextjs.org/) (React 기반, 2016)
  - [Nuxt.js](https://nuxtjs.org/) (Vue 기반, 2016)

### 2. SSG (Static Site Generation)

SSR과 달리 빌드 시점에 정적 HTML 파일을 미리 생성하여 배포하는 방식. 빠른 로딩 속도와 SEO 최적화가 가능하다. 실시간 데이터 반영이 필요없는 페이지들에 적합하다. 예를 들어, 블로그 포스트나 정책 문서와 같이 자주 변경되지 않는 콘텐츠에 적합하다.

- **원리**: 빌드 시점에 HTML 파일을 생성 → 클라이언트에서 요청 시 정적 파일 제공
- 대표적인 프레임워크
  - [Next.js](https://nextjs.org/) (React 기반, 2016)
  - [Gatsby](https://www.gatsbyjs.com/) (React 기반, 2015)
  - [Hugo](https://gohugo.io/) (Go 기반, 2013)
  - [Jekyll](https://jekyllrb.com/) (Ruby 기반, 2008)

## 2020년대-현재: 현대 프론트엔드

2020년대에 들어서면서 프론트엔드 개발은 더욱 발전하고 다양화되고 있다. React, Vue, Angular 같은 프레임워크들은 계속해서 진화하고 있으며, 새로운 도구와 라이브러리들이 등장하고 있다. 단일 패러다임이 아닌, 상황별 최적화가 중심이 되고 있다.

페이지의 특성에 따라 CSR, SSR, SSG, ISR 등을 적절히 조합하여 사용할 수 있고, 최근에는 보다 더 나은 사용자 경험을 위해 [RSC(React Server Components)](https://react.dev/reference/rsc/server-components)와 [Streaming SSR](https://www.patterns.dev/react/streaming-ssr/), [PPR(Partial Pre Rendering)](https://nextjs.org/docs/app/getting-started/partial-prerendering) 같은 새로운 기술들이 소개되고 있다.

하루가 다르게 변화하는 프론트엔드 환경 속에서, 개발자들은 최적의 사용자 경험을 제공하기 위해 노력하고 있다.
따라서 이러한 변화에 발맞추어 지속적인 학습과 적응이 필요한 시기이다.

## Reference

- [MDN - 웹 서버란 무엇일까?](https://developer.mozilla.org/ko/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_web_server)
- [MDN - XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
- [Wikipedia - AJAX](<https://en.wikipedia.org/wiki/Ajax_(programming)>)
- [짧게 써보는 웹 프론트엔드의 역사](https://velog.io/@minsangk/%EC%A7%A7%EA%B2%8C-%EC%8D%A8%EB%B3%B4%EB%8A%94-%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%9D%98-%EC%97%AD%EC%82%AC#3-phpaspjsp)
- [React Router 원리와 활용법 - React, 알고 쓰자 6일차](https://www.promleeblog.com/blog/post/248-6-react-router)
- [The Benefits of Server Side Rendering Over Client Side Rendering](https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8)
- [프론트엔드 렌더링 패러다임의 변화와 의미(ft. RSC, Streaming SSR, PPR)](https://de-velop-humus.tistory.com/30)
- [시니어 개발자가 말하는, 프론트엔드 역사와 미래](https://yozm.wishket.com/magazine/detail/1289/)
