---
title: 자바스크립트 함수
date: '2025-08-20'
lastmod: '2024-08-25'
tags: ['javascript']
draft: false
summary: 함수, 순수함수, 고차함수, 일급함수 개념 정리
---

프로그래밍에서 함수는 단순히 어떤 입력을 받아서 출력을 내보내는 도구 그 이상이다.

특히 JavaScript에서는 함수가 **일급 객체(First-Class Citizen)** 로 취급되기 때문에 다양한 패러다임을 가능하게 만든다.
이번 글에서는 함수, 순수 함수, 일급 함수, 고차 함수에 대해 정리한다.

## TLDR;

- 함수는 입력을 받아 출력을 반환하는 코드 블록이다.
- 함수는 함수 선언문, 함수 표현식, 화살표 함수, 생성자 함수 등 다양한 방법으로 정의할 수 있다.
- 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하고, 외부 상태를 변경하지 않는다.
- 일급 함수는 값처럼 다룰 수 있는 함수를 의미한다.
- 고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수를 말한다.

## 함수(Function)

함수는 특정 작업을 수행하기 위해 작성된 코드 블록이다.  
입력을 받아서 출력을 반환하는 구조를 가진다.

```js
function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // 5
```

그런데 우리가 함수를 사용하는 이유는 무엇일까? 아래 3가지 이유 정도가 될 것이다.

1. **재사용성**: 함수를 정의해두면, 필요할 때마다 호출하여 재사용할 수 있다.
2. **가독성**: 복잡한 로직을 함수로 분리하면 코드가 더 깔끔해지고 이해하기 쉬워진다.
3. **유지보수**: 버그 수정이나 기능 추가가 필요할 때, 함수 단위로 수정할 수 있어 편리하다.

### 함수 선언문, 함수 표현식, 화살표 함수, 생성자 함수

함수는 여러 가지 방법으로 정의할 수 있다.

1. **함수 선언문**: `function` 키워드를 사용하여 함수를 정의하는 전통적인 방법이다. 함수 선언문 전체가 호이스팅되어 함수 선언 이전에 호출할 수 있고, this는 동적으로 바인딩되어 함수가 어떻게 호출되는지에 따라 달라진다.

   ```js
   console.log(add(2, 3)); // 5

   function add(a, b) {
     console.log(this);
     return a + b;
   }

   console.log(add(2, 3)); // Window { ... } 5

   const obj = {
     func: add,
   };

   console.log(obj.func(2, 3)); // { func: [Function: add] } 5
   ```

2. **함수 표현식**: 함수를 변수에 할당하는 방법이다. 식별자 add까지만 호이스팅되어, 함수 선언 이전에 호출하면 에러가 발생한다. 함수 선언문과 마찬가지로 this는 동적으로 바인딩된다.

   ```js
   console.log(add(2, 3)); // ReferenceError: add is not defined

   const add = function (a, b) {
     console.log(this);
     return a + b;
   };

   console.log(add(2, 3)); // Window { ... } 5

   const obj = {
     func: add,
   };

   console.log(obj.func(2, 3)); // { func: [Function: add] } 5
   ```

3. **화살표 함수**: ES6에서 도입된 간결한 함수 표현식이다. 함수 표현식과 마찬가지로 식별자 add까지만 호이스팅되어, 함수 선언 이전에 호출하면 에러가 발생한다. 화살표 함수는 this를 동적으로 바인딩하지 않고, 선언된 위치의 상위 스코프에서 this를 상속받는다. 즉, 화살표 함수의 this는 함수가 작성된 환경에 따라 결정된다.

   ```js
   console.log(add(2, 3)); // ReferenceError: add is not defined

   const add = (a, b) => a + b;
   const add2 = (a, b) => {
     console.log(this);
     return a + b;
   };

   const obj = {
     name: 'obj',
     func: add2,
     func2: function () {
       const innerFunc = () => {
         return `${this.name} func2 inner`;
       };
       return innerFunc();
     },
   };

   console.log(obj.func(2, 3)); // Window { ... } 5
   console.log(obj.func2()); // 'obj func2 inner'
   ```

4. **생성자 함수**: 생성자 함수는 인스턴스를 생성하기 위한 함수이다. 일반적으로 대문자로 시작하는 이름을 가지며, `new` 키워드를 사용하여 호출한다. 생성자 함수도 함수 선언문의 형태이므로 선언 전에 호출되어도 에러가 발생하지 않는다. 생성자 함수 내에서 `this`는 새로 생성된 인스턴스를 가리킨다.

   ```js
   const alice = new Person('Alice', 30);
   console.log(alice.name); // Alice
   console.log(alice.age); // 30

   function Person(name, age) {
     this.name = name;
     this.age = age;
   }
   ```

## 순수 함수(Pure Function)

순수 함수는 동일한 입력에 대해 항상 동일한 출력을 내고,
외부 상태를 변경하지 않는 함수를 말한다.

```js
// 순수 함수
function multiply(a, b) {
  return a * b;
}

// 비순수 함수 (외부 변수 변경)
let total = 0;
function addToTotal(value) {
  total += value;
}
```

순수 함수는 어떤 때에 필요할까?
사실 대부분의 함수는 웬만하면 순수 함수로 작성하는 것이 좋다.
만약 하나의 변수를 여러 곳에서 수정하는 함수들이 있다면, 그 코드는 예측하기 어려운, 디버깅하기 어려운 코드가 될 것이다.

순수함수의 장점은 다음과 같다.

1. **예측 가능성**: 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하므로, 코드의 동작을 예측하기 쉽다.
2. **테스트 용이성**: 외부 상태에 의존하지 않기 때문에, 단위 테스트가 용이하다.
3. **병렬 처리**: 부작용이 없으므로, 여러 곳에서 동시에 호출해도 안전하다.

## 일급함수(First-Class Function)

JavaScript에서 함수는 **일급 객체**로 취급된다. <br />
일급 객체란 무엇일까?
일급 객체는 프로그래밍 언어에서 값으로 다룰 수 있는 모든 것을 말한다.

- **무명의 리터럴로 생성 가능**: 함수를 이름 없이 정의할 수 있다.
- **변수에 할당 가능**: 함수를 변수나 자료구조(객체, 배열)에 할당할 수 있다.
- **인자로 전달 가능**: 함수를 다른 함수의 인자로 전달할 수 있다.
- **반환값으로 사용 가능**: 함수를 다른 함수의 반환값으로 사용할 수 있다.

숫자, 문자열, 배열, 객체, 함수 등이 모두 위 조건을 충족하므로 일급 객체라고 할 수 있다.

```js
// 1. 무명의 리터럴로 생성 가능
const noName = function (name) {
  return `Hello, ${name}`;
};

const greet = (name) => `Hello, ${name}`; // 2. 변수에 할당 가능
function execute(fn, value) {
  // 3. 인자로 전달 가능
  return fn(value); // 4. 반환값으로 사용 가능
}
console.log(execute(greet, 'Alice')); // Hello, Alice
```

그럼 JavaScript에서 함수는 모두 일급함수일텐데, 왜 굳이 일급함수라는 용어가 생긴걸까? <br />

일급 함수란 **함수를 값처럼 자유롭게 다룰 수 있는 함수**를 의미하며, 언어 설계 관점에서 함수가 변수에 담기고, 인자로 전달되며, 반환값으로 사용될 수 있는지를 구분하기 위해 생긴 용어다.  
특히 함수형 프로그래밍에서는 이 특성이 핵심인데, 고차 함수나 콜백 패턴을 이해하려면 함수가 일급이라는 점이 필수적이다.  
즉, JS에서는 모든 함수가 일급이지만, “일급 함수”라는 용어는 **함수의 값으로서의 활용 가능성을 강조하기 위해** 존재한다고 이해하면 된다.

## 고차함수(Higher-Order Function)

고차 함수는 함수를 인자로 받거나 함수를 반환하는 함수를 말한다. <br />
JavaScript에서 고차 함수는 흔히 배열 메서드(map, filter, reduce)에서 자주 볼 수 있다.

```js
// 함수를 인자로 받는 경우
function applyOperation(arr, operation) {
  return arr.map(operation);
}

console.log(applyOperation([1, 2, 3], (x) => x * 2)); // [2, 4, 6]

// 함수를 반환하는 경우
function createMultiplier(multiplier) {
  return function (x) {
    return x * multiplier;
  };
}

const double = createMultiplier(2);
console.log(double(5)); // 10
```

React에는 고차컴포넌트(Higher-Order Component, HOC)라는 개념이 있다. <br />
아래와 같이 withLogging 함수를 만들어 재사용성을 높일 수 있다.
예전에는 HOC 패턴이 많이 사용되었지만, 요즘은 React Hooks를 통해 비슷한 기능을 구현하는 경우가 많다.

```js
import React from 'react';

function withLogging(WrappedComponent) {
  return function (props) {
    console.log('Rendering:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

const EnhancedComponent = withLogging(MyComponent);
```

이렇듯 고차함수를 사용하면 코드의 재사용성을 높이고 추상화를 할 수 있다.

## Reference

- [모던 자바스크립트 Deep Dive](https://product.kyobobook.co.kr/detail/S000001766445)
- [위키독스 - 순수 함수와 불변성](https://wikidocs.net/274948)
- [위키독스 - 일급 함수와 고차 함수](https://wikidocs.net/274949)
- [Patterns - HOC 패턴](https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/)
