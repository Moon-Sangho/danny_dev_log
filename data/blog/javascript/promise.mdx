---
title: 자바스크립트 Promise
date: '2025-08-21'
tags: ['javascript']
draft: false
summary: Promise의 개념과 사용법
---

[이전 글(Callback)](https://dannydevlog.vercel.app/blog/javascript/callback)에서 비동기 처리를 위한 콜백 함수의 사용법에 대해 알아보았다. 이번 글에서는 Promise를 통해 비동기 처리를 더 간편하게 하는 방법을 살펴보겠다.

## Promise란?

Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체이다.

Promise가 등장하기 전에는 비동기 작업 처리 시 콜백 함수에 의존했으나, 콜백 헬, 에러처리의 어려움, 가독성 저하 등의 이유로 ES6(ECMAScript 2015)에서 도입되었다.

비동기 작업이 성공하면 `resolve` 함수를 호출하고, 실패하면 `reject` 함수를 호출하여 결과를 처리할 수 있다.

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) resolve('완료');
    else reject('실패');
  }, 1000);
});

promise
  .then((result) => console.log(result))
  .catch((error) => console.log(error));
```

## Promise의 상태

### 1. pending

- Promise가 생성되고, 비동기 작업이 아직 완료되지 않은 상태이다.
- 아직 `resolve`나 `reject`가 호출되지 않은 상태이다.

### 2. fulfilled

- 비동기 작업이 성공적으로 완료된 상태이다.
- Promise 함수 내부에서 받는 `resolve` 콜백 함수를 호출해야 fulfilled 상태가 된다.
- `.then` 메서드를 사용하여 fulfilled 상태의 결과를 처리할 수 있다.

### 3. rejected

- 비동기 작업이 실패한 상태이다.
- Promise 함수 내부에서 받는 `reject` 콜백 함수를 호출해야 rejected 상태가 된다.
- `.catch` 메서드를 사용하여 rejected 상태의 에러를 처리할 수 있다.
- `.then`의 두 번째 인자로도 에러를 처리할 수 있지만, 가독성을 위해 에러처리는 `.catch`에서 하는 것이 좋다.

## Promise의 정적 메서드

Promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다. Promise는 5가지 정적 메서드를 제공한다.

### 1. Promise.resolve

Promise.resolve는 다음과 같은 상황의 경우 사용할 수 있다.

- 이미 동기적으로 얻은 값을 Promise로 래핑해 비동기 흐름에 통합할 때.
- 함수가 Promise를 반환해야 하지만 비동기 작업이 필요 없는 경우.
- Promise 체이닝을 시작하거나 테스트 목적으로 사용.

```js
function getCachedUsers() {
  const cachedData = [{ id: 1, name: 'Leanne Graham' }]; // 캐싱된 데이터 가정
  return Promise.resolve(cachedData); // 즉시 Fulfilled Promise 반환
}

getCachedUsers()
  .then((data) => {
    console.log('캐싱된 data:', data);
    // 캐시된 데이터가 없을 경우 실제 API 호출로 전환
    if (!data) {
      return fetch('https://jsonplaceholder.typicode.com/users');
    }
  })
  .then((response) => {
    console.log('response', response);
  })
  .catch((error) => console.error('에러:', error));
```

### 2. Promise.reject

Promise.reject는 아래와 같은 상황에서 사용할 수 있다.

- 특정 조건에서 즉시 에러를 발생시켜야 할 때.
- 테스트에서 에러 케이스를 시뮬레이션하거나, 비동기 흐름에서 에러를 강제로 발생시킬 때.
- 유효하지 않은 입력을 빠르게 거부하고자 할 때.

```js
function fetchUsers(userId) {
  if (!Number.isInteger(userId) || userId <= 0) {
    return Promise.reject(new Error('유효하지 않은 사용자 ID'));
  }
  return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`).then(
    (response) => {
      if (!response.ok) {
        throw new Error('사용자를 찾을 수 없음');
      }
      return response.json();
    }
  );
}

fetchUsers(-1)
  .then((data) => console.log('사용자:', data))
  .catch((error) => console.error('에러:', error.message)); // 출력: 에러: 유효하지 않은 사용자 ID
```

### 3. Promise.all

Promise.all은 여러 개의 Promise를 동시에 실행하고(병렬 처리), 모든 Promise가 fulfilled 상태가 될 때까지 기다린다. 모든 Promise가 성공해야 결과를 반환하며, 하나라도 실패하면 전체가 실패한다.

주로 API들의 호출 완료 순서가 서로에게 영향을 미치지 않고, 모든 작업이 완료된 후에 어떠한 결과를 처리하고자 할 때 사용된다.

```js
const promise1 = new Promise((resolve) => setTimeout(() => resolve(1), 1000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 2000));
const promise3 = new Promise((resolve) => setTimeout(() => resolve(3), 3000));

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log('All promises fulfilled:', results);
  })
  .catch((error) => {
    console.error('One or more promises rejected:', error);
  });
```

### 4. Promise.allSettled

Promise.allSettled는 여러 개의 Promise를 동시에 실행하고, 모든 Promise의 결과가 완료될 때까지 기다린다. 각 Promise의 결과는 fulfilled 또는 rejected 상태로 반환되며, 모든 결과를 배열로 받을 수 있다.

```js
const promise1 = new Promise((resolve) => setTimeout(() => resolve(1), 1000));
const promise2 = new Promise((resolve, reject) =>
  setTimeout(() => reject('Error'), 2000)
);
const promise3 = new Promise((resolve) => setTimeout(() => resolve(3), 3000));

Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  results.forEach((result) => {
    if (result.status === 'fulfilled') {
      console.log('Promise fulfilled with value:', result.value);
    } else {
      console.error('Promise rejected with reason:', result.reason);
    }
  });
});
```

### 5. Promise.race

Promise.race는 여러 개의 Promise 중 가장 먼저 fulfilled 또는 rejected 상태가 된 Promise의 결과를 반환한다. 나머지 Promise는 무시된다. 아래와 같이 타임아웃 처리를 위해 사용할 수 있다.

```js
function timeout(ms) {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`타임아웃: ${ms}ms 내에 응답 없음`)), ms);
  });
}

function fetchUsersWithTimeout() {
  const apiPromise = fetch('https://jsonplaceholder.typicode.com/users').then(
    (response) => {
      if (!response.ok) {
        throw new Error(`요청 실패: 상태 코드 ${response.status}`);
      }
      return response.json();
    }
  );

  // 3초 타임아웃 설정
  return Promise.race([apiPromise, timeout(3000)]);
}

fetchUsersWithTimeout()
  .then((data) => {
    console.log('사용자 데이터:', data);
    data.forEach((user) =>
      console.log(`이름: ${user.name}, 이메일: ${user.email}`)
    );
  })
  .catch((error) => {
    console.error('에러:', error.message);
  });
```

## Promise의 장단점

### 1. 장점

- 가독성이 높아진다.
- 에러 처리가 간편해진다.

### 2. 단점

- Promise가 중첩되면 가독성이 떨어질 수 있다(콜백 헬과 유사한 형태로, Promise 헬이 될 수 있다).
- 비동기 작업이 순차적으로 실행되어야 할 때, `.then` 체이닝이 길어질 수 있다.

---

이처럼 Promise는 비동기 작업을 처리하는 데 있어 콜백 함수보다 더 나은 가독성과 에러 처리를 제공한다. 하지만 Promise 사용 시에도 위에서 언급한 것처럼 중첩된 Promise에서는 가독성이 떨어질 수 있다. 이를 해결하기 위해 async/await 문법이 도입되었다. 다음 글에서는 async/await에 대해 알아보겠다.

## Reference

- [모던 자바스크립트 Deep Dive](https://product.kyobobook.co.kr/detail/S000001766445)
- [MDN - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
