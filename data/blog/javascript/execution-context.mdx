---
title: 실행 컨텍스트
date: '2025-08-08'
tags: ['javascript']
draft: false
summary: 실행 컨텍스트의 개념과 동작 원리
---

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다. <br />
실행 컨텍스트를 이해함으로써 스코프, 클로저, 호이스팅, 비동기 처리 등을 이해할 수 있고,
궁극적으로 디버깅 능력을 향상시킬 수 있다.

## TLDR;

- 실행 컨텍스트는 자바스크립트 소스코드를 실행하는 데 필요한 환경 정보들을 모아놓은 객체이다.
- 실행 컨텍스트는 스택 자료구조로 관리된다.
- 실행 컨텍스트에는 아래 정보가 저장된다.
  - VariableEnvironment
  - LexicalEnvironment
  - ThisBinding
- LexicalEnvironment의 environmentRecord와 outerEnvironmentReference를 통해 스코프 체이닝이 이루어진다.
- ThisBinding은 식별자가 바라봐야 할 대상 객체를 가리킨다.

## 실행 컨텍스트란?

실행 컨텍스트는 자바스크립트 소스코드를 실행하는 데 필요한 환경 정보들을 모아놓은 객체이다. <br />
동일한 환경에서 실행되는 코드들을 위한 실행 컨텍스트를 생성하고, 이를 통해 코드의 실행 결과를 관리한다. <br />

## 실행 컨텍스트의 생성과 실행 과정

실행 컨텍스트는 스택 자료구조로 관리된다. <br />
예를 들어보면, 아래와 같은 코드가 있다고 가정해보자.

```javascript
// ---------------------------- (1)
var a = 1;
function outer() {
  function inner() {
    console.log(a);
    var a = 3;
  }
  inner(); // ---------------- (2)
  console.log(a);
}
outer(); // ---------------- (3)
console.log(a);
```

실행 컨텍스트의 생성과 실행 과정은 아래와 같다.

![execution-context](/static/images/execution-context.webp)

1. <ins>처음 자바스크립트 코드를 실행하는 순간(1)</ins> 전역 컨텍스트가 콜 스택에 담긴다.
2. <ins>outer 함수를 호출(3)</ins>하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer
   실행 컨텍스트를 생성한 후 콜 스택에 담는다.
3. <ins>inner 함수를 호출(2)</ins>하면 자바스크립트 엔진은 inner에 대한 환경 정보를 수집해서 inner
   실행 컨텍스트를 생성한 후 콜 스택에 담는다.
4. inner 함수 내부에서 console.log(a)가 실행되고, 더 이상의 작업이 없으니 inner 실행 컨텍스트가 콜 스택에서 제거된다.
5. outer 함수 내부에서 console.log(a)가 실행되고, 더 이상의 작업이 없으니 outer 실행 컨텍스트가 콜 스택에서 제거된다.
6. 전역 컨텍스트만 남아있게 되고, 전역 컨텍스트에서 더 이상의 작업이 없으니 전역 컨텍스트가 콜 스택에서 제거된다.

## 실행 컨텍스트에 저장되는 정보

실행 컨텍스트에는 아래와 같은 정보가 저장된다.

### 1. VariableEnvironment

현재 컨텍스트 내의 식별자들에 대한 정보와 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음.
이후 몇 가지 상황을 만나면 VariableEnvironment를 위한 새로운 LexicalEnvironment를 생성하고, 이 때부터 VariableEnvironment와 LexicalEnvironment는 다른 값을 가질 수 있다.

VariableEnvironment에는 아래 항목들이 포함된다.

- environmentRecord(snapshot): 현재 컨텍스트 내의 식별자들에 대한 정보. 변수, 함수 선언문, 매개변수의 이름 등
- outerEnvironmentReference(snapshot): 외부 환경 정보.

이 글에서는 LexicalEnvironment만을 중심으로 설명하겠다.

### 2. LexicalEnvironment

처음에는 VariableEnvironment와 동일하지만, 변경사항이 실시간으로 반영됨.
아래 항목들이 포함된다.

- environmentRecord: 현재 컨텍스트 내의 식별자들에 대한 정보. 변수, 함수 선언문, 매개변수의 이름 등
- outerEnvironmentReference: 외부 환경 정보.

### 3. ThisBinding

식별자가 바라봐야 할 대상 객체.

## LexicalEnvironment의 environmentRecord와 호이스팅

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. <br />
예를 들어, `var` 키워드로 선언된 변수와 함수 선언문의 형식으로 선언된 함수를 예로 들어보자.

```javascript
console.log(x); // (1) undefined
var x = 1;

test(); // (2) test
function test() {
  console.log('test');
}
```

변수나 함수 선언의 시점보다 console.log와 함수를 실행했는데도, 함수가 문제없이 잘 실행된다. <br />
마치 자바스크립트 엔진이 코드를 실행하기 전에 식별자 정보들을 모두 알고있는 것처럼 보인다. <br />
이런 현상을 위로 끌어올려졌다는 의미로, <b>호이스팅(hoisting)</b>이라고 한다. <br />

(1)에서 undefined가 출력되는 이유는 2가지를 짚고 넘어가야 한다.

1. 실행 컨텍스트는 값의 할당 라인은 수집하지 않는다.
2. `var` 키워드로 변수를 선언하게 되면 변수 선언, 초기화 과정이 모두 이루어지고, 이 때 변수는 undefined로 초기화된다.

→ 실행 컨텍스트의 입장에서는 `var x` 까지만 수집을 했으므로, 아직 값의 할당이 이루어지지 않은 상태이다.

(2)에서 짚고 넘어가야 할 점은 함수 선언문 자체가 실행 컨텍스트에 등록된다는 점이다. <br />
함수 표현식으로 선언된 함수는 식별자의 정보만 등록된다. <br />
함수 표현식의 경우 아래와 같이 함수 선언부보다 위에서 함수를 호출하면 에러가 발생한다.

```javascript
a(); // ReferenceError: a is not defined
const a = function () {
  console.log('a');
};
```

## LexicalEnvironment의 outerEnvironmentReference와 스코프 체이닝

outerEnvironmentReference는 현재 컨텍스트의 외부 환경 정보를 가리킨다. <br />
예를 들어, 아래와 같은 코드가 있다고 가정해보자.

```javascript
var x = 1;
function outer() {
  var y = 2;
  function inner() {
    var z = 3;
    console.log(x + y + z);
  }
  inner();
}
outer();
```

inner 함수 내부에서 x, y, z 변수를 참조하고 있다. <br />
이 때, inner 함수의 outerEnvironmentReference는 outer 함수의 LexicalEnvironment를 가리킨다. <br />

1. inner 함수 내부에서 x 변수를 찾는다. <br />
2. inner 함수의 외부(outer 함수의 LexicalEnvironment)에서 x 변수를 찾는다. <br />
3. outer 함수 내부에 x 변수가 없으므로, outer 함수의 외부에서 x 변수를 찾는다. <br />
4. 전역 컨텍스트에 x가 있으므로 해당 값을 참조한다.

이렇게 특정 값을 찾기 위해 외부 환경 정보를 계속해서 찾아나가는 것을 스코프 체이닝이라고 한다. <br />

## ThisBinding

ThisBinding은 식별자가 바라봐야 할 대상 객체를 가리킨다. <br />
자바스크립트에서는 함수가 선언될 때가 아니라 호출될 때 this 값이 정해진다. <br />

위에서 봤었던 코드를 다시 보자.

```javascript
var x = 1;
function outer() {
  var y = 2;
  function inner() {
    var z = 3;
    console.log(x + y + z);
  }
  inner();
}
outer();
```

outer 함수의 ThisBinding은 전역 객체를 가리킨다. <br />
inner 함수의 ThisBinding은 outer 함수의 LexicalEnvironment를 가리킨다. 즉, 전역 객체를 가리킨다. <br />
환경 별 전역 객체는 다음과 같다.

- 브라우저에서는 window 객체를 가리킨다.
- Node.js에서는 global 객체를 가리킨다.
- strict mode에서는 undefined를 가리킨다.

이번에는 객체의 메서드를 호출하는 경우를 살펴보자.

```javascript
const obj = {
  name: 'John',
  sayHello: function () {
    console.log(this.name);
  },
};

obj.sayHello();
```

obj.sayHello() 메서드를 호출하면, sayHello 메서드 내부에서 this는 obj 객체를 가리킨다. <br />
이 때, ThisBinding은 obj 객체를 가리키게 된다.

ThisBinding이 왜 필요한지, ThisBinding의 규칙들에는 어떤 것들이 있는지는 다음 글에서 다루겠다.
