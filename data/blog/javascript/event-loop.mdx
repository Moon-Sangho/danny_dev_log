---
title: 이벤트 루프
date: '2025-08-12'
tags: ['javascript']
draft: false
summary: 이벤트 루프의 개념과 동작 원리
---

이벤트 루프는 자바스크립트의 비동기 처리 모델을 구현하는 핵심 요소이다. <br />
이벤트 루프의 개념을 이해함으로써 비동기 코드의 동작을 예측할 수 있고, 성능 최적화와 디버깅 능력을 향상시킬 수 있다.

## TLDR;

- 이벤트 루프는 자바스크립트의 동시성을 지원하는 핵심 메커니즘이다.
- Call Stack, Web APIs, Task Queue, Microtask Queue, AnimationFrame Queue가 협력하여 동작한다.
- 비동기 작업의 실행 순서는 일반적으로 Microtask Queue > AnimationFrame Queue > Task Queue이다.

## 이벤트 루프란?

자바스크립트는 싱글 스레드 언어다. <br />
즉, 한 번에 하나의 작업만 처리할 수 있고, 모든 코드는 Call Stack이라는 하나의 실행 스택 위에서 순차적으로 실행된다.

그런데 웹 애플리케이션에서는 API 호출, 파일 읽기, 타이머, 사용자 이벤트 등 오래 걸리는 작업이 많다. <br />
만약 이런 작업이 모두 스택에서 직접 실행된다면? → 브라우저는 멈추고 사용자는 "응답 없음"을 보게 된다.

실제로 우리가 브라우저를 사용할 때를 생각해보면 알림, 이미지 로딩, 동영상 재생 등 동시에 일어나는 작업이 많다. <br />
자바스크립트는 이러한 동시성을 어떻게 지원하는 걸까? <br />

이 문제를 해결하기 위해 브라우저와 Node.js는 <b>이벤트 루프(Event Loop)</b>라는 메커니즘을 사용한다. <br />
이벤트 루프는 간단히 말해 <b>비동기 작업 목록(Queue)에서 실행 가능한 작업을 꺼내 스택에 올리는 관리자</b>다.

## 구조도

![event-loop](/static/images/event-loop-1.webp)

이벤트 루프는 다음 요소들이 협력하면서 동작한다.

### 1. JS Engine

#### 1.1. Memory Heap

- 개발자가 프로그램에 선언한 변수, 함수 등이 저장되는 공간

#### 1.2. Call Stack

- 자바스크립트 코드가 실행되는 장소
- 함수를 호출하면 스택에 쌓이고, 끝나면 빠진다. (Last In First Out)

### 2. Web APIs (또는 Node.js APIs)

- 브라우저나 Node.js가 제공하는 API들
- 예: setTimeout, DOM 이벤트, Fetch API 등

### 3. Task Queue (Callback Queue)

- Call Stack이 비어있을 때 실행할 함수들이 대기하는 큐 (First In First Out)
- 예: setTimeout 콜백, DOM 이벤트 핸들러

### 4. Event Loop

- "스택이 비었나?"를 끊임없이 확인하고, 비었다면 큐에서 작업을 꺼내 자바스크립트의 Call Stack에 쌓도록 하는 관리자

## 동작 원리

아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

console.log(3);
```

답은 1, 3, 2이다. <br />
이와 같은 순서대로 출력되는 과정은 다음과 같다.

1. console.log(1) → Call Stack에 쌓인 후 실행됨
2. setTimeout → Web API로 전달, 0ms 후 Task Queue에 콜백 추가
3. console.log(3) → Call Stack에 쌓인 후 실행됨
4. 스택이 비어있으니 이벤트 루프가 이를 확인하고 Task Queue에서 콜백을 꺼내 스택에 쌓음
5. console.log(2) → Call Stack에 쌓인 후 실행됨

이번엔 아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

Promise.resolve().then(() => {
  console.log(3);
});

console.log(4);
```

답은 1, 4, 3, 2이다. <br />
왜 이런 결과가 나오는 걸까? <br />
Promise는 <b>Microtask Queue</b>로 분류되는데, 이는 Task Queue보다 우선순위가 높다. <br />
따라서 스택이 비어있을 때 Task Queue에 쌓인 코드보다 Microtask Queue에 쌓인 코드가 먼저 실행된다.

Microtask Queue에 쌓이는 함수들은 Promise 콜백, MutationObserver, queueMicrotask 등이 있다.

이번엔 아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

requestAnimationFrame(() => {
  console.log(2);
});

setTimeout(() => {
  console.log(3);
}, 0);

Promise.resolve().then(() => {
  console.log(4);
});

console.log(5);
```

답은 1, 5, 4, 2, 3이다. <br />
requestAnimationFrame은 또 뭐길래 setTimeout보다 먼저 실행될까? <br />
requestAnimationFrame은 주로 반복적인 애니메이션을 최적화하기 위해 사용되는 Web API다. <br />
브라우저가 다음 번 repaint(화면 갱신) 전에 실행할 수 있도록 AnimationFrame Queue에 쌓는다. <br />
Microtask queue보다 우선순위가 낮지만, Task queue보다 우선순위가 높다. <br />

그런데 requestAnimationFrame은 브라우저의 repaint 주기에 맞춰 실행되기 때문에,
환경에 따라 setTimeout보다 먼저 실행될 수도 있고 나중에 실행될 수도 있다. (브라우저마다 결과가 다르게 나올 수도 있다.) <br />

25.08.12 기준 크롬, 파이어폭스 브라우저 콘솔에서 위 코드를 실행해보면, setTimeout보다 늦게 실행되는 경우도 있었다.

글 초반부에 첨부했던 구조도에서 Microtask queue와 AnimationFrame Queue가 빠져있으니,
다음 그림으로 구조를 보완한다.

![event-loop-2](/static/images/event-loop-2.webp)

## Reference

- [자바스크립트와 이벤트 루프](https://meetup.nhncloud.com/posts/89)
- [JavaScript Visualized: Event Loop](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif)
- [어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU](https://www.youtube.com/watch?v=8aGhZQkoFbQ)
- [Jake Archibald: 루프 속 - JSConf.Asia](https://www.youtube.com/watch?v=cCOL7MC4Pl0)
