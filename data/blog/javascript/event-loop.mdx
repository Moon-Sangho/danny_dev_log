---
title: 이벤트 루프
date: '2025-08-12'
lastmod: '2024-08-13'
tags: ['javascript']
draft: false
summary: 이벤트 루프의 개념과 동작 원리
---

이벤트 루프는 자바스크립트의 비동기 처리 모델을 구현하는 핵심 요소이다. <br />
이벤트 루프의 개념을 이해함으로써 비동기 코드의 동작을 예측할 수 있고, 성능 최적화와 디버깅 능력을 향상시킬 수 있다.

## TL;DR

- 이벤트 루프는 자바스크립트의 동시성을 지원하는 핵심 메커니즘이다.
- Call Stack, Web APIs, Task Queue, Microtask Queue, AnimationFrame Queue가 협력하여 동작한다.
- 비동기 작업의 실행 순서는 일반적으로 Microtask Queue > AnimationFrame Queue > Task Queue이다.

## 이벤트 루프란?

자바스크립트는 싱글 스레드 언어다. <br />
즉, 한 번에 하나의 작업만 처리할 수 있고, 모든 코드는 Call Stack이라는 하나의 실행 스택 위에서 순차적으로 실행된다.

그런데 웹 애플리케이션에서는 API 호출, 파일 읽기, 타이머, 사용자 이벤트 등 오래 걸리는 작업이 많다. <br />
만약 이런 작업이 모두 스택에서 직접 실행된다면? → 브라우저는 멈추고 사용자는 "응답 없음"을 보게 된다.

실제로 우리가 브라우저를 사용할 때를 생각해보면 알림, 이미지 로딩, 동영상 재생 등 동시에 일어나는 작업이 많다. <br />
자바스크립트는 이러한 동시성을 어떻게 지원하는 걸까? <br />

이 문제를 해결하기 위해 브라우저와 Node.js는 <b>이벤트 루프(Event Loop)</b>라는 메커니즘을 사용한다. <br />
이벤트 루프는 간단히 말해 <b>비동기 작업 목록(Queue)에서 실행 가능한 작업을 꺼내 스택에 올리는 관리자</b>다.

## 구조도

![event-loop](/static/images/event-loop-1.webp)

이벤트 루프는 다음 요소들이 협력하면서 동작한다.

### 1. JS Engine

#### 1.1. Memory Heap

- 개발자가 프로그램에 선언한 변수, 함수 등이 저장되는 공간

#### 1.2. Call Stack

- 자바스크립트 코드가 실행되는 장소
- 함수를 호출하면 스택에 쌓이고, 끝나면 빠진다. (Last In First Out)

### 2. Web APIs (또는 Node.js APIs)

- 브라우저나 Node.js가 제공하는 API들
- 예: setTimeout, DOM 이벤트, Fetch API 등

### 3. Task Queue (Callback Queue)

- Call Stack이 비어있을 때 실행할 함수들이 대기하는 큐 (First In First Out)
- 예: setTimeout 콜백, DOM 이벤트 핸들러

### 4. Event Loop

- "스택이 비었나?"를 끊임없이 확인하고, 비었다면 큐에서 작업을 꺼내 자바스크립트의 Call Stack에 쌓도록 하는 관리자

## 동작 원리

아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

console.log(3);
```

답은 1, 3, 2이다. <br />
이와 같은 순서대로 출력되는 과정은 다음과 같다.

1. console.log(1) → Call Stack에 쌓인 후 실행됨
2. setTimeout → Web API로 전달, 0ms 후 Task Queue에 콜백 추가
3. console.log(3) → Call Stack에 쌓인 후 실행됨
4. 스택이 비어있으니 이벤트 루프가 이를 확인하고 Task Queue에서 콜백을 꺼내 스택에 쌓음
5. console.log(2) → Call Stack에 쌓인 후 실행됨

이번엔 아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

Promise.resolve().then(() => {
  console.log(3);
});

console.log(4);
```

답은 1, 4, 3, 2이다. <br />
왜 이런 결과가 나오는 걸까? <br />
Promise는 <b>Microtask Queue</b>로 분류되는데, 이는 Task Queue보다 우선순위가 높다. <br />
따라서 스택이 비어있을 때 Task Queue에 쌓인 코드보다 Microtask Queue에 쌓인 코드가 먼저 실행된다.

Microtask Queue에 쌓이는 함수들은 Promise 콜백, MutationObserver, queueMicrotask 등이 있다.

이번엔 아래 코드의 실행 결과를 예측해보자.

```js
console.log(1);

requestAnimationFrame(() => {
  console.log(2);
});

setTimeout(() => {
  console.log(3);
}, 0);

Promise.resolve().then(() => {
  console.log(4);
});

console.log(5);
```

이론적인 답은 1, 5, 4, 2, 3이다. <br />
requestAnimationFrame은 또 뭐길래 setTimeout보다 먼저 실행될까? <br />
requestAnimationFrame은 주로 반복적인 애니메이션을 최적화하기 위해 사용되는 Web API다. <br />
브라우저가 다음 번 repaint(화면 갱신) 전에 실행할 수 있도록 AnimationFrame Queue에 쌓는다. <br />
Microtask queue보다 우선순위가 낮지만, Task queue보다 우선순위가 높다. <br />

그런데 위 코드를 브라우저 콘솔에서 새로고침을 해보며 반복적으로 실행하다보면, requestAnimationFrame이 setTimeout보다 늦게 실행되는 경우도 있었다. <br />
왜 이런 현상이 발생할까? <br />
이 현상을 이해하려면 모니터 주사율(Hz)과 브라우저의 렌더링 타이밍을 이해해야 한다.

---

### 1. 브라우저 렌더링 사이클과 FPS

- 모니터는 보통 60Hz(1초에 60번)로 화면을 갱신한다.
  - 한 프레임은 16.67ms 동안 유지된다.
- 브라우저는 이 리프레시 타이밍에 맞춰서 아래 과정들을 반복한다.
  - 이벤트 처리 — 사용자 입력, 네트워크 응답 등 처리
  - 자바스크립트 실행 — 이벤트 핸들러, 타이머 콜백 등 실행
  - 레이아웃(Layout) 계산 — DOM의 요소 위치와 크기 계산
  - 페인트(Paint) — 각 요소를 픽셀 단위로 채색
  - 화면 리프레시(Render) — 완성된 프레임을 모니터에 출력

### 2. requestAnimationFrame의 타이밍

- rAF 콜백은 다음 프레임의 paint 직전에 실행된다.
- 중요한 점: 이 실행 시점은 현재 프레임이 끝나기 직전이 아니라, 다음 프레임의 paint 직전이다.
- 따라서 호출 시점이 모니터의 프레임 경계선에 얼마나 가까운지가 실행 타이밍에 큰 영향을 준다.

### 3. setTimeout의 타이밍

- setTimeout(fn, 0)은 최소 지연 시간이 브라우저에 따라 보통 1~4ms 이상이다.
- rAF처럼 프레임 경계선에 묶이지 않고, 이벤트 루프의 Task Queue에 들어간 뒤 바로 처리된다.
- 만약 rAF 예약이 프레임 경계선을 넘겨버리면, 다음 프레임(최대 16.67ms 뒤)까지 대기하게 된다.

### 4. 순서가 역전되는 경우

다음과 같은 타이밍이면 rAF가 setTimeout보다 늦게 실행될 수 있다.

1. 두 함수를 거의 동시에 예약했는데, 예약 시점이 프레임 경계에 매우 가까움
2. requestAnimationFrame 예약이 현재 프레임의 paint 직전이 아니라 다음 프레임의 paint 직전으로 밀림
3. setTimeout은 바로 다음 이벤트 루프 사이클에서 실행 → rAF보다 먼저 실행됨

즉, rAF는 FPS에 맞춰 실행되지만, setTimeout은 FPS와 무관하게 실행되기 때문에 프레임 타이밍에 따라 순서가 뒤바뀔 수 있다.
이 문제를 해결하려면 setTimeout에 적절한 지연 시간을 설정해야 한다.
예를 들어, 내 모니터가 60Hz라면 16.67ms의 지연 시간을 설정해야 한다.
그러나 유저들마다 각자 다른 주사율의 모니터를 가지고 있기 때문에, 이 방법은 어떤 환경에서든지 완벽하게 호출 순서를 보장할 수 없다.

따라서 실무에서 setTimeout과 requestAnimationFrame을 함께 사용할 때는 주의가 필요하다.

---

글 초반부에 첨부했던 구조도에서 Microtask queue와 AnimationFrame Queue가 빠져있으니,
다음 그림으로 구조를 보완한다. 아래 그림에서 Task Queue는 Macrotask Queue라고도 한다.

![event-loop-2](/static/images/event-loop-2.webp)

## Reference

- [자바스크립트와 이벤트 루프](https://meetup.nhncloud.com/posts/89)
- [JavaScript Visualized: Event Loop](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif)
- [어쨌든 이벤트 루프는 무엇입니까? | Philip Roberts | JSConf EU](https://www.youtube.com/watch?v=8aGhZQkoFbQ)
- [Jake Archibald: 루프 속 - JSConf.Asia](https://www.youtube.com/watch?v=cCOL7MC4Pl0)
