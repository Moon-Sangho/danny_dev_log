---
title: SWC는 어떻게 Babel보다 빠를까?
date: '2025-11-13'
tags: ['bundler']
draft: false
summary: SWC가 Babel보다 빠른 이유에 대해 알아보자.
---

JavaScript 생태계에서 트랜스파일 도구로 널리 사용되는 Babel과 SWC는 각각의 설계 철학과 구현 방식에서 큰 차이를 보인다. 특히 SWC는 속도 면에서 Babel보다 월등히 빠르다는 평가를 받고 있다. 이번 글에서는 SWC가 Babel보다 왜 빠른지 그 이유를 공부해보자.

## TL;DR

- SWC는 Rust로 작성된 멀티스레드 아키텍처를 사용하여 병렬 처리를 통해 여러 파일을 동시에 처리할 수 있다.
- 반면 Babel은 JavaScript로 작성된 싱글스레드 아키텍처로, 파일을 순차적으로 처리하기 때문에 대규모 프로젝트에서 속도 저하가 발생할 수 있다.
- 토이프로젝트에서 자체 벤치마크 결과 SWC는 Babel보다 약 10% 더 빨랐으며, TerserPlugin의 swcMinify 옵션까지 사용했을 때는 약 40%의 속도 향상을 기록했다.

## SWC란?

먼저 SWC가 무엇인지에 대해 간단히 살펴보자.
SWC(Speedy Web Compiler)는 Rust로 작성된 JavaScript/TypeScript 컴파일러로, 빠른 속도와 효율성을 목표로 한다. SWC는 주로 Transpiling, Bundling, Minification 등의 작업을 수행하며, 특히 대규모 프로젝트에서 뛰어난 성능을 발휘한다고 한다.

## Babel과 SWC의 차이점

Babel은 JavaScript로 작성된 트랜스파일러로, 다양한 플러그인과 프리셋을 통해 광범위한 기능을 제공한다. 반면 SWC는 Rust로 작성되어 메모리 관리와 병렬 처리에서 뛰어난 성능을 보인다. 이러한 언어적 차이점이 두 도구의 속도 차이에 큰 영향을 미친다.

| 구분        | Babel             | SWC                        |
| ----------- | ----------------- | -------------------------- |
| 언어        | JS                | Rust (네이티브)            |
| 아키텍처    | 싱글 스레드       | 멀티 스레드                |
| 처리 방식   | 인터프리터 스타일 | 컴파일러 스타일            |
| 병렬 처리   | 거의 없음         | CPU 코어 거의 풀로 사용    |
| 메모리 접근 | 느림(JS 엔진)     | 빠름(Rust + Native 메모리) |

위 표에서 알 수 있듯이, SWC는 Rust의 성능 이점을 활용하여 병렬 처리를 통해 여러 파일을 동시에 처리할 수 있다. 반면 Babel은 싱글 스레드로 동작하기 때문에 대규모 프로젝트에서 속도 저하가 발생할 수 있다.

더 구체적인 예시를 통해 싱글스레드와 멀티스레드의 작업방식 차이를 살펴보자.

### 1. Babel (싱글 스레드)

CPU가 8코어라면 Babel은 한 번에 1코어만 사용하여 파일을 순차적으로 처리한다.
만약 빌드 대상 파일이 300개라고 하면 아래와 같이 한 번에 하나의 파일 작업이 끝난 뒤에야 다음 파일을 처리한다.

```
파일1 → 파싱
파일2 → 파싱
파일3 → 파싱
...
```

그래서 프로젝트의 규모가 커질수록 체감 속도는 급격히 느려진다.

### 2. SWC (멀티 스레드)

CPU가 8코어라면 SWC는 최대 8코어를 활용하여 여러 파일을 동시에 처리할 수 있다.

```
스레드1: 파일1, 파일2, 파일3 → 파싱
스레드2: 파일4, 파일5, 파일6 → 파싱
스레드3: 파일7, 파일8, 파일9 → 파싱
...
```

그래서 파일 수가 많아질수록 속도 이득은 기하급수적으로 증가한다.

## 직접 비교해보기

두 도구의 성능 차이를 직접 비교해보기 위해 동일한 프로젝트를 각각 Babel과 SWC로 빌드해보았다.
왓챠를 클론 코딩한 작은 토이 프로젝트고, webpack config에서 TerserPlugin을 사용하여 compress, mangle 옵션을 켠 상태로 빌드했다.

```js
// webpack.prod.mjs
	...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
		// https://webpack.js.org/plugins/terser-webpack-plugin/#swc
        minify: TerserPlugin.swcMinify, // swc 마이그레이션 후에 추가해주었다.
        terserOptions: {
          compress: true, // 공백, 주석 제거 등 코드 최소화
          mangle: true, // 변수명, 함수명 난독화
        },
      }),
    ],
  },
```

환경은 MacOS M3, 8코어, 16GB RAM이고, 각각 로컬에서 5회씩 빌드 시간을 측정하여 평균을 냈다.
아래는 간단한 벤치마크 결과이다.

### 1. Webpack + Babel

1. 3,842 ms
2. 3,445 ms
3. 3,386 ms
4. 3,381 ms
5. 3,391 ms

**평균: 3,489 ms**

### 2. Webpack + SWC

1. 3,263 ms
2. 3,085 ms
3. 3,217 ms
4. 3,028 ms
5. 3,006 ms

**평균: 3,120 ms**

### 3. Webpack + SWC + TerserPlugin.swcMinify

1. 2,435 ms
2. 2,048 ms
3. 2,051 ms
4. 1,958 ms
5. 1,945 ms

**평균: 2,087 ms**

### 4. 결과 분석

위 벤치마크 결과를 보면 **SWC**(평균 3,120 ms)가 **Babel**(평균 3,489 ms)보다 약 10% 더 빠른 것을 알 수 있다.
그리고 **TerserPlugin의 swcMinify 옵션까지 사용**(평균 2,087 ms)했을 때는 Babel을 사용했을 때보다 약 40%의 속도 향상을 기록했다.

## 결론

SWC는 Rust로 작성된 멀티스레드 아키텍처 덕분에 Babel보다 훨씬 빠른 성능을 제공한다. 특히 대규모 프로젝트에서 그 차이는 더욱 두드러지며, 빌드 시간을 단축시키는 데 큰 도움이 된다. 따라서 빠른 빌드 속도가 중요한 프로젝트에서는 SWC를 고려해보는 것이 좋을 것 같다.

Next.js에서는 이미 SWC를 기본 트랜스파일러로 밀고 있으니, 앞으로 더 많은 프로젝트에서 SWC의 채택이 늘어날 것으로 기대된다.

## Reference

- [SWC 공식 문서](https://swc.rs/)
- [초보 웹 개발자를 위한 자바스크립트 빌드 툴과 SWC](https://tech.kakaoent.com/front-end/2022/220217-learn-babel-terser-swc/)
