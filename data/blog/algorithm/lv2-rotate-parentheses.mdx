---
title: 괄호 회전하기
date: '2025-12-23'
tags: ['algorithm']
draft: false
summary: 프로그래머스 lv.2 괄호 회전하기 문제 풀이
---

## 문제 설명

다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

- `(), [], {}` 는 모두 올바른 괄호 문자열입니다.
- 만약 A가 올바른 괄호 문자열이라면, `(A), [A], {A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
- 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 `x (0 ≤ x < (s의 길이))` 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

- 문제 링크: [프로그래머스 - 괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)

### 제한사항

s의 길이는 1 이상 1,000 이하입니다.

## 내 풀이

```javascript
const rotate = (s, num) => {
  const arr = s.split('');
  for (let i = 0; i < num; i++) {
    const el = arr.shift();
    arr.push(el);
  }
  return arr;
};

const isValid = (arr) => {
  const stack = [];
  const pair = { ')': '(', ']': '[', '}': '{' };

  for (const v of arr) {
    if (v === '(' || v === '[' || v === '{') {
      stack.push(v);
    } else {
      if (stack.length === 0) return false;
      const top = stack.pop();
      if (top !== pair[v]) return false;
    }
  }
  return stack.length === 0;
};

const solution = (s) => {
  let answer = 0;

  for (let i = 0; i < s.length; i++) {
    const arr = rotate(s, i);
    const valid = isValid(arr);
    if (valid) {
      answer++;
    }
  }

  return answer;
};

solution('[](){}'); // 3
```

문제를 풀기 전 사고 흐름은 아래와 같다.

1. x 값의 범위가 0부터 s의 길이 -1 까지이므로, 반복문을 사용해 내부에서 조건 계산 후 answer를 하나씩 증가시켜야겠다.
2. 반복문 내부에서는 문자열을 회전시키는 기능이 필요할 것이고, (함수 분리)
3. 회전된 문자열이 올바른 괄호 문자열인지 판단하는 기능이 필요할 것이다. (함수 분리)
4. 마지막으로 valid하다고 판단되면 answer를 증가시키고, 반복문이 끝나면 answer를 반환하면 되겠다.

## Lesson Learned

내 풀이에서 아쉬운 점은 rotate 함수에서 문자열을 배열로 변환한 후, shift와 push를 사용해 회전시키는 부분이다.
JS 배열에서 shift 메서드는 맨 앞 요소를 빼고 나머지 원소들을 전부 한 칸씩 당겨야 해서 시간 복잡도가 O(n)이다. 그런데 반복문 안에서 동작하므로 O(n²)이 된다.
또, solution 함수에서도 반복문이 사용되니 최악의 경우 시간 복잡도는 O(n³)이 된다.

따라서 문자열의 길이가 길어질수록 성능 저하가 발생할 수 있다.

rotate 함수에서 아래와 같이 문자열 슬라이싱을 활용하면 더 간단하고 효율적으로 구현할 수 있다.

```js
const rotate = (s, num) => [...s.slice(num), ...s.slice(0, num)];
```

이렇게 하면 반복문을 사용하지 않으므로 rotate 함수의 시간 복잡도가 O(n²)에서 O(n)으로 줄어든다.

따라서 solution 함수의 최종 시간 복잡도는 O(n²)로 개선될 수 있다.
