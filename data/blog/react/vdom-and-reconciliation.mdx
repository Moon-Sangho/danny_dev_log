---
title: Virtual DOM과 Reconciliation
date: '2025-09-19'
tags: ['react']
draft: false
summary: React의 Virtual DOM과 Reconciliation 과정에 대해 알아보기
---

리액트의 핵심 개념 중 **Virtual DOM**과 **Reconciliation**이 있다. 이 두 가지 개념은 리액트가 효율적으로 UI를 업데이트하고 렌더링하는 데 중요한 역할을 한다.
이번 글에서는 Virtual DOM과 Reconciliation이 무엇인지, 그리고 어떻게 작동하는지에 대해 자세히 알아보자.

## TL;DR

- **Virtual DOM**: 메모리 상에 존재하는 자바스크립트 객체로, 실제 DOM과 1:1 대응되는 구조. 상태 변화 시 새로운 Virtual DOM 트리를 생성하고 이전 트리와 비교(diff)하여 실제 DOM에 최소 변경만 반영함으로써 성능을 최적화한다.
- **Reconciliation**: 리액트가 상태 변화에 따라 UI를 업데이트하는 과정. 새로운 Virtual DOM 트리를 생성하고 이전 트리와 비교하여 변경된 부분만 실제 DOM에 반영한다.
- 리액트는 더블 버퍼링(Double Buffering) 기법을 사용하여 `current` 트리와 `workInProgress` 트리를 번갈아 가며 관리한다. 이를 통해 부드러운 UI 경험을 제공한다.
- **Diffing 알고리즘**: 두 트리를 비교할 때, 다른 타입의 Elements는 제거 후 새로 생성하고, 같은 타입의 Elements는 attributes만 비교하여 변경된 부분만 업데이트한다. 리스트에서는 각 아이템에 고유한 키(key)를 부여하여 효율적으로 관리되도록 한다.

## Virtual DOM과 Reconciliation 개념

**Virtual DOM**이란 DOM 업데이트를 최소화하기 위해 구축한 메모리 상의 자바스크립트 객체이다. 실제 DOM과 1:1 대응되는 구조이며, 리액트는 상태가 바뀌면 이 가상트리를 새로 만들고 이전 트리와 비교(diff)한 뒤 실제 DOM에 필요한 최소 변경만 반영해서 DOM 조작 비용을 줄인다. 실제 DOM 조작은 비용이 많이 드는 작업이기 때문에, Virtual DOM을 사용함으로써 DOM 업데이트를 최소화할 수 있다.

**Reconciliation**은 리액트가 상태 변화에 따라 UI를 업데이트하는 과정이다. 리액트는 새로운 Virtual DOM 트리를 생성하고, 이전 트리와 비교하여 변경된 부분만 실제 DOM에 반영한다. 따라서 이 Reconciliation 과정에서 DOM 업데이트 비용을 줄일 수 있다.

## Virtual DOM을 기반으로 Reconciliation이 동작하는 과정

### 1. 초기 렌더링 (mount 단계)

- 리액트는 컴포넌트의 JSX를 바탕으로 Fiber 객체들로 구성된 Virtual DOM 트리를 생성한다.
- 이때 만들어진 트리가 `current` 트리 가 된다. 즉, 실제 DOM과 1:1로 연결된 "현재 화면을 나타내는" 트리다.

### 2. 상태 변경 발생 (update 단계 시작)

- 컴포넌트의 state나 props가 변경되면, 리액트는 새로운 렌더링을 준비한다.
- 이때 기존 `current` 트리를 기반으로 `workInProgress`라는 새로운 트리를 생성한다.
- `workInProgress` 트리는 업데이트를 적용해 나가는 과정에서 "작업 중인 복제본" 역할을 한다.

### 3. Render Phase (Diffing 알고리즘 수행)

- 리액트는 `workInProgress` 트리를 만들면서, 이전의 `current` 트리와 비교(diff)한다.
- 어떤 노드가 변경되었는지, 추가/삭제되었는지를 계산한다.
- 이 단계는 브라우저 DOM에는 아직 반영되지 않고, 메모리 상에서만 일어난다.

### 4. Reconciliation (commit 준비 단계)

- 변경 사항이 정리되면, 실제 DOM에 반영하기 위한 "효율적인 업데이트 경로"가 결정된다.
- 전체 UI를 리렌더링하는 대신, 변경된 부분만 업데이트할 수 있도록 한다.

### 5. Commit Phase (DOM 업데이트 & 트리 교체)

- 준비된 변경 사항을 실제 DOM에 반영한다.
- 이때, 기존의 `current` 트리는 버려지고, 방금까지 작업하던 `workInProgress` 트리가 새로운 `current` 트리가 된다.
- 즉, 화면에 반영된 결과물이 `current` 트리로 확정되는 것이다.

이렇게 2개의 트리를 활용하는 방식을 더블 버퍼링(Double Buffering)이라고 한다. 더블 버퍼링이란 그래픽스/게임 쪽에서 흔히 사용되는 기법으로, 두 개의 버퍼를 번갈아 가며 사용하는 방식이다. 하나의 버퍼가 화면에 표시되는 동안, 다른 버퍼는 다음 프레임을 준비하는 데 사용된다.

리액트에서는 `current` 트리가 화면에 표시되는 동안, `workInProgress` 트리가 다음 상태를 준비하는 역할을 한다. 이 방식을 통해 유저는 끊김 없는 부드러운 UI 경험을 할 수 있다.

## Diffing 알고리즘

두 트리를 비교할 때 React는 먼저 두 루트 요소를 비교한다. 루트 요소의 타입에 따라 동작이 달라진다.

1. **다른 타입의 Elements**: 다른 타입의 Elements는 이전 Elements를 제거하고 새 Elements를 생성한다.
   아래와 같은 예제의 같은 경우 `<div>`와 `<span>`은 다른 타입이므로, 리액트는 기존의 `<Counter />`를 제거하고 새로 생성한다.

   ```jsx
   <div>
     <Counter />
   </div>

   <span>
     <Counter />
   </span>
   ```

2. **같은 타입의 Elements**: 같은 타입의 Elements는 attributes만 비교하여 변경된 부분만 업데이트한다.
   아래와 같은 예제의 경우, `<div>` 요소의 `className`과 `title` 속성만 비교하여 변경된 `className`만 실제 DOM에 반영한다.

   ```jsx
   <div className="before" title="stuff" />

   <div className="after" title="stuff" />
   ```

   아래 예제의 경우, `style` 객체의 color 속성 값이 변경되었으므로, 변경된 color 속성만 실제 DOM에 반영한다.

   ```jsx
   <div style={{ color: 'red', fontWeight: 'bold' }} />

   <div style={{ color: 'green', fontWeight: 'bold' }} />
   ```

3. **키(key) 사용**: 리스트에서 각 아이템에 고유한 키를 부여하여, 아이템의 추가/삭제/순서 변경을 효율적으로 처리한다.
   아래 예제에서 만약 `<li>` 요소들에 key를 부여하지 않았다면, 리액트는 순서만 바뀐 것을 감지하지 못하고, 모든 `<li>` 요소를 제거하고 새로 생성하는 비효율적인 작업을 수행할 수 있다. 하지만 key를 부여하면 리액트는 어떤 아이템이 이동했는지 정확히 파악할 수 있다. 따라서 기존 `<li>` 요소들을 재사용하고, 순서만 변경할 수 있다.

   ```jsx
   // <li> 순서 변경 전
   <ul>
    <li key="A">A</li>
    <li key="B">B</li>
   </ul>

   // <li> 순서 변경 후
   <ul>
    <li key="B">B</li>
    <li key="A">A</li>
   </ul>
   ```

왜 이러한 룰을 만들게 되었을까? 대부분의 아티클들에서 아래처럼 설명한다.

> n개의 엘리먼트가 있는 트리를 다른 트리로 변환하는 알고리즘의 복잡도는 최소 O(n³)로 알려져 있다고 한다. 리액트는 이 문제를 해결하기 위해 위와 같은 룰을 적용하여 O(n)의 휴리스틱 알고리즘을 달성했다.

위 문장만 봤을 때 직관적으로 이해되지 않을 수 있다. 예시를 통해 이해해보자.

```jsx
이전 트리:           새 트리:
   A                 A
  / \               / \
 B   C             C   B
```

위와 같이 이전 트리와 새로운 트리를 비교해야 한다고 해보자.
즉, B와 C의 위치가 서로 바뀐 경우이다.

사람 눈에는 "아, 순서만 바뀌었네"라고 쉽게 알 수 있지만, 컴퓨터(알고리즘) 입장에서는 그게 맞는지 확인하려면 경우의 수를 다 따져봐야 한다.

1. **순서만 바뀐 것으로 해석**

- 위치는 달라졌지만, 원래 있던 B와 C를 그대로 재사용. 즉, 순서만 바뀐 것으로 해석하는 경우.
- 우리가 기대하는 "최적" 해석.

2. **이름이 바뀐 것으로 해석**

- "혹시 이전의 B가 지금은 C로 바뀐 거고, C가 B로 바뀐 건 아닐까?" 라고 해석하는 경우.
- B 노드를 C로 교체, C 노드를 B로 교체.

3. **둘 다 삭제 후 새로 생성해야 하는 경우로 해석**

- 더 극단적으로, "이전의 B는 없어지고 새 C가 추가된 거고, C는 없어지고 새 B가 추가된 것"으로 해석하는 경우.

이렇게 경우의 수가 많아지면, 노드가 늘어날수록 조합이 폭발적으로 증가하게 된다.
이 때문에 "모든 경우를 따져서 최적의 매칭을 찾자" 하면 O(n³) 복잡도가 돼버려서 계산이 너무 느려지게 된다.
따라서 리액트는 위에서 설명한 3가지 룰을 적용하여, 경우의 수를 대폭 줄이고 O(n) 복잡도의 휴리스틱 알고리즘을 달성한 것이다.

> 휴리스틱이란 완벽하게 최적의 해답을 찾기엔 너무 비싸거나 느릴 때, "적당히 빠르게 괜찮은 답을 찾기 위한 규칙"을 의미한다.

## 마치며

이번 글에서는 리액트의 핵심 개념인 Virtual DOM과 Reconciliation에 대해 알아보았다. Virtual DOM은 실제 DOM 조작 비용을 줄이기 위해 메모리 상에 올려둔 자바스크립트 객체이며, Reconciliation은 상태 변화에 따라 UI를 효율적으로 업데이트하는 과정이다. 리액트는 더블 버퍼링 기법을 활용하여 부드러운 UI 경험을 제공하며, Diffing 알고리즘을 통해 변경된 부분만 실제 DOM에 반영함으로써 성능을 최적화한다.

그러나 Virtual DOM과 Reconciliation이 항상 최적의 성능을 보장하는 것은 아니다. Virtual DOM을 메모리에 생성하고, 상태 변화를 비교하며 업데이트할 부분을 계산하는 과정에도 비용이 발생하기 때문이다. 특히 컴포넌트 구조가 복잡하거나 상태 변화가 자주 일어나는 경우에는, 실제 DOM을 직접 업데이트하는 것보다 Virtual DOM 연산이 더 많은 시간을 소모해 오히려 성능이 떨어질 수 있다. 따라서 개발자는 컴포넌트를 가능한 단순하게 설계하고, 불필요한 리렌더링을 줄이는 최적화 전략도 함께 고려해야 한다.

## Reference

- [React - Reconciliation](https://legacy.reactjs.org/docs/reconciliation.html)
- [What is the Virtual DOM in React?](https://www.freecodecamp.org/news/what-is-the-virtual-dom-in-react/)
- [React 파이버 아키텍처 분석](https://d2.naver.com/helloworld/2690975)
- [React 톺아보기 - 02. Intro](https://goidle.github.io/react/in-depth-react-intro/)
